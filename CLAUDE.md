# CLAUDE.md

## Project Overview

React Native IAP - A high-performance in-app purchase library using Nitro Modules

## Key Technologies

- React Native
- Nitro Modules (Native bridge)
- TypeScript
- Swift (iOS with StoreKit 2)
- Kotlin (Android with Google Play Billing)
- **Yarn 3** (Package manager with workspace support)

## Package Manager

⚠️ **IMPORTANT: This project uses Yarn 3 with workspaces**

- **Workspace Structure**: Only `example` is in the yarn workspace. `example-expo` is an independent project
- Install dependencies: `yarn install` (installs for library and example only)
- Add packages to library: `yarn add [package]`
- Add packages to example: `yarn workspace rn-iap-example add [package]`
- Add packages to example-expo: `cd example-expo && bun add [package]` (independent)
- Run scripts: `yarn [script]`
- Execute packages: `yarn dlx [package]` or `npx [package]`

## Project Structure

```sh
src/
├── index.tsx           # Main exports and API
├── specs/
│   └── RnIap.nitro.ts # Nitro interface definitions (native bridge)
└── types/
    └── *.ts           # TypeScript type definitions

ios/
├── HybridIAP.swift    # iOS native implementation (StoreKit 2)
└── *.swift            # Other iOS implementation files

android/
└── src/main/java/com/margelo/nitro/iap/
    └── *.kt           # Android native implementation (Play Billing)

nitrogen/
└── generated/         # Auto-generated Nitro bridge files (DO NOT EDIT)

example/               # React Native example app (workspace)
├── ios/
├── android/
└── package.json

example-expo/          # Independent Expo example app (NOT in workspace)
├── app/
├── scripts/
└── package.json       # Uses bun, independent from yarn workspace
```

### Auto-generated Files

- `src/types.ts` is generated; never edit manually. Update the underlying schema/spec and rerun the generators instead.

## Development Commands

### Building and Code Generation

```bash
# Generate Nitro bridge files (nitrogen)
yarn specs

# TypeScript type checking
yarn typecheck

# Linting
yarn lint
yarn lint --fix

# Clean build artifacts
yarn clean
```

### Example App (React Native - Workspace)

```bash
# No need to navigate to example directory or install separately
# Dependencies are managed via workspaces

# iOS
cd example && yarn ios
cd example && yarn ios --device  # For physical device

# Android
cd example && yarn android

# Start Metro bundler
cd example && yarn start

# Or from root:
yarn workspace rn-iap-example ios
yarn workspace rn-iap-example android
yarn workspace rn-iap-example start
```

### Example-Expo (Independent Project)

```bash
# Independent project - requires separate setup
# Uses bun and expo setup script

# Initial setup (copies lib files and builds)
cd example-expo && bun setup

# iOS
cd example-expo && bun ios
cd example-expo && bun ios --device  # For physical device

# Android
cd example-expo && bun android

# Start Metro bundler
cd example-expo && bun start
```

### iOS Setup

```bash
# For example (workspace)
cd example/ios
bundle install  # Install Ruby dependencies
bundle exec pod install  # Install iOS dependencies

# For example-expo (independent)
cd example-expo/ios
pod install  # iOS dependencies
```

## VSCode Integration

The project includes VSCode launch configurations for easy development:

1. **Nitrogen + iOS Simulator**: Generates Nitro files and runs on iOS simulator
2. **Nitrogen + iOS Device**: Generates Nitro files and runs on physical iOS device
3. **Nitrogen + Android**: Generates Nitro files and runs on Android

Access these from the Run and Debug panel (⌘⇧D) in VSCode.

## Architecture Guidelines

### Module Organization

1. **src/specs/RnIap.nitro.ts** - Native Bridge Interface
   - Contains the Nitro interface definition that bridges to native code
   - Includes ALL native method declarations
   - This is the contract between TypeScript and native implementations

2. **nitrogen/** - Auto-generated Files
   - Generated by `bun run specs`
   - Contains C++ bridge code and type definitions
   - **DO NOT EDIT** - These files are auto-generated

3. **Native Implementation**
   - iOS: `ios/HybridIAP.swift` - StoreKit 2 implementation
   - Android: `android/.../Iap.kt` - Play Billing implementation with auto-reconnection
   - **Connection Management**: Uses Google Play Billing v8.0.0+ automatic service reconnection

## Coding Standards

### Commit Message Convention

- **With tag**: Use lowercase after tag (e.g., `feat: add new feature`, `fix: resolve bug`)
- **Without tag**: Start with uppercase (e.g., `Add new feature`, `Fix critical bug`)
- Common tags: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`

### Code Style

- ESLint configuration for TypeScript
- Prettier for code formatting
- TypeScript with strict mode
- Use type-only imports when importing types (`import type`)

### Native Class Function Ordering Convention

When organizing native implementation classes (Swift/Kotlin), follow this strict ordering:

1. **Properties and Initialization** - Class properties, init, deinit
2. **Public Cross-platform Methods** - Methods without platform suffixes (e.g., `initConnection`, `fetchProducts`)
3. **Platform-specific Public Methods** - Methods with IOS/Android suffixes (e.g., `getStorefrontIOS`, `consumePurchaseAndroid`)
4. **Event Listener Methods** - Methods for managing event listeners
5. **Private Helper Methods** - All private implementation details

Example structure:

```swift
class HybridRnIap {
    // MARK: - Properties
    private var isInitialized: Bool = false

    // MARK: - Initialization
    override init() { }

    // MARK: - Public Methods (Cross-platform)
    func initConnection() { }
    func fetchProducts() { }

    // MARK: - iOS-specific Public Methods
    func getStorefrontIOS() { }
    func clearTransactionIOS() { }

    // MARK: - Event Listener Methods
    func addPurchaseUpdatedListener() { }

    // MARK: - Private Helper Methods
    private func ensureConnection() { }
    private func convertToNitroProduct() { }
}
```

## CI Checks (Run Before Committing)

**IMPORTANT**: Always run these checks locally before committing to avoid CI failures:

```bash
# Install dependencies
yarn install

# TypeScript Check
yarn typecheck

# Linting
yarn lint --fix

# Generate Nitro files if specs changed
yarn specs

# Run all checks in sequence
yarn install && yarn typecheck && yarn lint --fix
```

## Hook API Semantics (useIAP)

- Inside the `useIAP` hook, most methods return `Promise<void>` and update internal state. Do not design examples that expect returned data from these methods.
  - Examples: `fetchProducts`, `requestProducts` (if present), `requestPurchase`, `getAvailablePurchases`.
  - After calling, consume state from the hook: `products`, `subscriptions`, `availablePurchases`, etc.
- Defined exceptions in the hook that DO return values:
  - `getActiveSubscriptions(subscriptionIds?) => Promise<ActiveSubscription[]>` (also updates `activeSubscriptions` state)
  - `hasActiveSubscriptions(subscriptionIds?) => Promise<boolean>`
- The root (index) API is value-returning and can be awaited to receive data directly. Use root API when not using React state.

### Common CI Fixes

- TypeScript errors: Ensure all types are properly imported
- Linting errors: Use `bun run lint --fix` to auto-fix formatting issues
- Nitro generation: Run `bun run specs` after modifying `.nitro.ts` files

## Platform-Specific Features

### iOS (StoreKit 2)

- Subscription management
- Promotional offers
- Family sharing
- Refund requests
- Transaction verification
- Receipt validation

### Android (Play Billing)

- Multiple SKU purchases
- Subscription offers
- Obfuscated account/profile IDs
- Purchase acknowledgment
- Product consumption
- **Automatic Service Reconnection** - Uses `enableAutoServiceReconnection()` to handle disconnections automatically
- **Simplified Connection Handling** - Only checks if billing client exists (not connection state), auto-reconnection handles the rest

## Error Handling

### Centralized Error Management

The project uses a centralized error handling approach across all platforms:

**TypeScript (`src/utils.ts` + `src/types.ts`)**

- `parseErrorStringToJsonObj()` - Parses native error strings into structured objects
- `isUserCancelledError()` - Helper to check for user cancellation
- `ErrorCode` enum (from types.ts) - Standardized error codes across platforms

**Android (`android/src/main/java/com/margelo/nitro/iap/Types.kt`)**

- `IapErrorCode` object - Centralized error codes
- `BillingUtils.getBillingErrorData()` - Maps Android billing codes to error objects
- `BillingUtils.createErrorJson()` - Serializes errors to JSON strings

**iOS (`ios/ErrorUtils.swift`)**

- `IapErrorCode` struct - iOS error code constants (matches Android)
- `ErrorUtils.getStoreKitErrorData()` - Maps StoreKit errors to error objects
- `ErrorUtils.createErrorJson()` - Serializes errors to JSON strings

### Error Format

All native modules return errors as JSON strings:

```json
{
  "code": "E_USER_CANCELLED",
  "message": "User cancelled the purchase",
  "responseCode": 1,
  "debugMessage": "User pressed cancel",
  "productId": "dev.hyo.martie.10bulbs"
}
```

### Usage Example

```typescript
import { parseErrorStringToJsonObj, isUserCancelledError } from 'react-native-iap'

try {
  await requestPurchase({ ... })
} catch (error) {
  const parsedError = parseErrorStringToJsonObj(error)

  if (isUserCancelledError(parsedError)) {
    console.log('User cancelled purchase')
  } else {
    console.error('Purchase failed:', parsedError.code, parsedError.message)
  }
}
```

### Common Error Codes

- `E_USER_CANCELLED` - User cancelled the operation
- `E_ITEM_UNAVAILABLE` - Product not available in store
- `E_NETWORK_ERROR` - Network connection issues
- `E_SERVICE_ERROR` - Platform service issues
- `E_DEVELOPER_ERROR` - Invalid API usage
- `E_NOT_PREPARED` - Service not initialized
- `E_UNKNOWN` - Unexpected error

## Development Guidelines

- Always use `yarn` for package management (project uses Yarn 3 with workspaces)
- Run `yarn typecheck` and `yarn lint` before committing
- Regenerate Nitro files with `yarn specs` after modifying interfaces
- Use Platform.OS checks for platform-specific code
- Handle errors gracefully using `parseErrorStringToJsonObj()` utility
- Test error scenarios on both platforms

## Troubleshooting

### Common Issues

1. **Build failures after modifying .nitro.ts files**
   - Run `yarn specs` to regenerate Nitro bridge files

2. **React Duplication Instance Issues** ⚠️
   - **Problem**: "Cannot read properties of null" or "useState of null" errors
   - **Cause**: Multiple React instances loaded due to workspace setup
   - **Solution**: Metro resolver alias configuration already applied in `example/metro.config.js`

   ```javascript
   // example/metro.config.js uses modern alias approach:
   resolver: {
     alias: {
       'react-native': path.resolve(__dirname, 'node_modules/react-native'),
       'react': path.resolve(__dirname, 'node_modules/react'),
       'react-native-iap': path.resolve(__dirname, '..'),
     }
   }
   ```

   - **Additional Notes**:
     - Resolutions are configured in root `package.json` (workspace level)
     - `example-expo` is **NOT** in yarn workspace (independent project)
     - Only `example` is included in workspace structure

3. **iOS build errors**

   ```bash
   cd example/ios
   bundle exec pod install
   ```

4. **Package installation issues**
   - Run `yarn install` from the root directory
   - Clear yarn cache: `yarn cache clean`
   - Delete node_modules and reinstall: `rm -rf node_modules example/node_modules && yarn install`

5. **Metro bundler issues**

   ```sh
   cd example
   yarn start --reset-cache
   ```
